<!--
<html>
  <head>
  <link rel="stylesheet" media="screen" href="http://handsontable.com/dist/handsontable.full.css">
  <link rel="stylesheet" media="screen" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">
  <style>
    body{padding:50px;}
    h3{text-align:center;}
    h4{padding-top: 20px;}
  </style>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
  <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/sylvester/0.1.3/sylvester.js" ></script>
  <script type="text/javascript" src="js/blackscholes.js" ></script>
  <script src="http://handsontable.com/dist/handsontable.full.js"></script>
  <script src="js/jquery.ui.myhandsontable.js"></script>
  <script type="text/javascript" src="https://www.google.com/jsapi?autoload={
      'modules':[{
        'name':'visualization',
        'version':'1',
        'packages':['corechart']
      }]
    }">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  </head>
  <body>
    <h3>Maximum Entropy Volatility Smile Fitter</h3>
    <p>This page calibrates a maximum entropy risk-neutral density function that is consistent with a number of European call implied volatilities with given strikes at the same maturity. All the computations are done on the client side using JavaScript.</p>
    <p> 
    <h4>Formal problem</h4>
    Maximize:
    $$\int f(x) \ln f(x) dx \;\;\;\;\; (1)$$
    Subject to:
    $$\int f(x) dx = 1 $$
    $$\int f(x) U_i(x) dx = C_i \;\;\;\;\; (2)$$
    Where:
    <ul>
    <li>\(U_i(x) = (S e^x - K_i )^+\): payoff of the i.th European call option</li>
    <li>\(K_i\): strike of the i.th option</li>
    <li>\(C_i = \it{BlackScholes}(S, K_i, \sigma_i, T, r) \): price of the i.th option using the BlackScholes formula</li>
    <li>\(\sigma_i\): BlackScholes implied volatility of the i.th option</li>
    <li>\(S = 100\): spot price</li>
    <li>\(T = 1\): maturity of the options</li>
    <li>\(r = 0\): risk-free rate</li>
    </ul>
    <h4>Solution</h4>
    <p>It can be shown, that density functions of the following form satisfy the maximum entropy condition \((1)\):
    $$f(x) = \exp \left[\lambda_0 + \sum_i \lambda_i U_i(x) \right], \;\;\;\;\; (3)$$
    where \(\lambda_i\) are the Lagrange multipliers. We use the Newton's method to find the Lagrange multipliers that are consistent with the  conditions \((2)\).
    </p>
    <h4>Demo</h4>
    <p>Please enter the strikes and implied volatilities in the following table.</p>
    <div id="handsontable"></div>
    <div id="status"></div>
    <div id="chart_pdf"></div>
    <div id="chart_IV"></div>
  </body>
  <script type="text/javascript">
 
  function assert(condition, message) {
    if (!condition) {
      message = message || "Assertion failed";
      if (typeof Error !== "undefined") {
        throw new Error(message);
      }
      throw message; // Fallback
    }
  }
 
  function plot(div_id, x, y, title, xlabel, ylabel) {
    assert(x.length==y.length)
    var d = new Array(x.length)
    for(i=0; i<x.length; i++) d[i] = [x[i],y[i]];
    var data = new google.visualization.DataTable();
    data.addColumn('number', 'X');
    data.addColumn('number', 'Y');
    data.addRows(d);
    var options = {
      title: title,
      hAxis: { title: xlabel },
      vAxis: { title: ylabel },
      legend: {position: 'none'}
    };
    var chart = new google.visualization.LineChart(document.getElementById(div_id));
    chart.draw(data, options);
  }
 
  function plotDataTableArray(div_id, dataTableArray, title, xlabel, ylabel) {
    var d = new Array(x.length)
    for(i=0; i<x.length; i++) d[i] = [x[i],y[i]];
    var data = new google.visualization.arrayToDataTable(dataTableArray);
    var options = {
      title: title,
      hAxis: { title: xlabel },
      vAxis: { title: ylabel },
      curveType: 'function',
      legend: {position: 'none'},
      series: {
        0: { lineWidth: 3, pointSize:3 },
        1: { lineWidth: 0, pointSize:10, color:'#e2431e' }
      }
    };
    var chart = new google.visualization.LineChart(document.getElementById(div_id));
    chart.draw(data, options);
  }
 
  function europeanPayout(x, S, K, callPut) {
    // x: Vector of x values
    // S: spot
    // K: strike
    // callPut: 1 for call, -1 for put
    // returns Vector of max0(callPut*(S*e^x-K))
    assert(callPut == -1 || callPut == 1);
    return x.map(function(x){ return Math.max(0,callPut*(S*Math.exp(x)-K));});
  }
 
  function getEuropeanPayouts(x, Ss, Ks, CallPuts) {
    // Ss, Ks, CallPuts: Vectors of size M
    // x: Vector of size N
    // returns: Matrix of size NxM
    N = x.elements.length;
    M = Ss.elements.length;
    payouts = Matrix.Zero(N,M);
    for(i=0; i<M; i++) {
      payout = europeanPayout(x, Ss.elements[i], Ks.elements[i], CallPuts.elements[i]);
      for(j = 0; j<N; j++) {
        payouts.elements[j][i] = payout.elements[j];
      }
    }
    return payouts;
  }
 
  function getPdf(lambdas, payouts, dx) {
    // lambdas: Vector of lambdas
    // payouts: Matrix of payouts
    // returns exp(sum_i lambdas[i]*payouts[i])
    assert(lambdas.elements.length == payouts.cols());
    var f = payouts.multiply(lambdas);
    return f.map(function(x){return Math.exp(x);}).multiply(dx);
  }
 
  function getExpectedPayouts(payouts, pdf) {
    return payouts.transpose().multiply(pdf);
  }
 
  function getJacobian(payouts, pdf) {
    // computes the Jacobian
    var M = payouts.cols()
    var PDF = pdf.toDiagonalMatrix();
    var A = Matrix.Zero(M,M);
    for(i=0; i<M; i++) {
      A.elements[i][i] = PDF.multiply(payouts.col(i+1)).dot(payouts.col(i+1));
      for(j=i+1; j<M; j++) {
        A.elements[i][j] = PDF.multiply(payouts.col(i+1)).dot(payouts.col(j+1));
        A.elements[j][i] = A.elements[i][j];
      }
    }
    return A;
  }
 
  function getNext(lambdas, gradient, alpha, Cs, payouts, dx) {
    // does one Gradient or Newton iteration and returnd null if fails or results if OK
    // lambdas: current lambdas aka X
    // gradient, direction in which we want to step
    // alpha: size of step
    // Cs: values that we want to reach
    // payouts: payout function Matrix
    // dx: grid size
    // return: [lambdas_new, gradient_new, alpha_new, resNorm] if successful or null if not
    var isGradient = false;
    console.log('getNext');
    console.log('alpha',alpha);
    lambdas_new = lambdas.dup().add(gradient.dup().multiply(alpha))
    console.log('lambdas_new',lambdas_new.inspect());
    var pdf = getPdf(lambdas_new, payouts, dx);
    if(!isFinite(pdf.dot(pdf))) {
      console.log('err: pdf is infinite');
      return null;
    }
    var residual = getExpectedPayouts(payouts, pdf).subtract(Cs);
    var resNorm = residual.dot(residual);
    console.log('residual norm',resNorm);
    var A = getJacobian(payouts, pdf);
    var AT = A.dup().transpose();
    if(isGradient) {
      gradient_new = AT.multiply(residual);
      Agradient_new = A.multiply(gradient_new);
      console.log('gradient_new',gradient_new.inspect())
      var alpha_new = - gradient_new.dot(gradient_new) / Agradient_new.dot(Agradient_new);
      if(isNaN(alpha_new)) {
        console.log('err: new alpha is NaN');
        return null;
      }
      return [lambdas_new, gradient_new, alpha_new, resNorm];
    }
    else {
      var invATA = AT.multiply(A).inv();
      if(invATA===null) {
        console.log('err: ATA is not invertible');
        return null;
      }
      gradient_new = invATA.multiply(AT).multiply(residual).multiply(-1);
      alpha_new = 1;
      return [lambdas_new, gradient_new, alpha_new, resNorm];
    }
  }
 
  function fitLambdas(payouts, dx, Cs, maxSteps) {
    // solves the max ent problem by calibrating the Lagrange multipliers
    // returns lambdas or throws if no solution
    var lambdas = Vector.Zero(Cs.elements.length);
    var gradient = Vector.Zero(Cs.elements.length);
    var alpha = 0;
    var prevResNorm = 1e100;
    internalMaxSteps = 2;
    for(iStep = 0; iStep<maxSteps; iStep++) {
      console.log('iStep',iStep);
      for(j=0; j<internalMaxSteps; j++) {
        if(j==internalMaxSteps-1) throw new Error('no solution found in internal loop');
        ret = getNext(lambdas, gradient, alpha, Cs, payouts, dx);
        if(!ret) {
          alpha *= 0.1;
          console.log('resnom increased, trying with 0.1 step length');
          continue;
        }
        resNorm = ret[3];
        if(resNorm > prevResNorm) {
          alpha *= 0.1;
          console.log('resnom increased, trying with 0.1 step length');
          continue;
        }
        if(resNorm < 1e-10) {
          console.log('Done');
          return lambdas;
        }
        lambdas = ret[0];
        gradient = ret[1];
        alpha = ret[2];
        console.log('alpha outer',alpha);
        prevResNorm = resNorm;
        break;
      }
    }
    throw new Error('no solution found in '+maxSteps+' steps');
  }
  
  function fitPdf(x, dx, S, Ks, CallPuts, Cs) {
    // fits max ent pdf to a set of given BS implied vols and strikes
    var M = Ks.elements.length;
    assert(M == CallPuts.elements.length);
    assert(M == Cs.elements.length);
    var Ss_ = Vector.Zero(M+2);
    var Ks_ = Vector.Zero(M+2);
    var CallPuts_ = Vector.Zero(M+2);
    var Cs_ = Vector.Zero(M+2);
    // values of European options
    for(i=0; i<M; i++) {
      Ss_.elements[i] = S; // today's spot
      Ks_.elements[i] = Ks.elements[i]; // strike
      CallPuts_.elements[i] = CallPuts.elements[i]; // 1 for call, -1 for put
      Cs_.elements[i] = Cs.elements[i];
    }
    // pdf normalization condition
    Ss_.elements[M] = 0;
    Ks_.elements[M] = 1;
    CallPuts_.elements[M] = -1;
    Cs_.elements[M] = 1;
    //future stock has expectation of todays price
    Ss_.elements[M+1] = 100;
    Ks_.elements[M+1] = 0;
    CallPuts_.elements[M+1] = 1;
    Cs_.elements[M+1] = S;
    var payouts = getEuropeanPayouts(x, Ss_, Ks_, CallPuts_);
    maxSteps = 20;
    lambdas = fitLambdas(payouts, dx, Cs_, maxSteps);
    pdf = getPdf(lambdas, payouts, dx);
    return pdf;
  }
  
  function generateGrid(N, dx) {
    var x = Vector.Zero(N);
    return x.map(function(x, i){return dx*(i-N/2);});
  }
 
  function plotResults(pdf, S, Ks_, IVs_, T, r) {
    plot("chart_pdf",x.elements,pdf.elements,"Probability Density Function","x=ln(K/S)","f(x)dx");
    // calculate prices of a set of calls and puts
    var minK = Ks_.e(1);
    var maxK = Ks_.e(1);
    for(i=1; i<=Ks.elements.length; i++) {
      if(Ks_.e(i)>maxK) maxK = Ks.e(i);
      if(Ks_.e(i)<minK) minK = Ks.e(i);
    }
    dK = maxK - minK;
    minK -= dK*0.15;
    maxK += dK*0.15;
    var N = 20;
    Ss = Vector.Zero(N).map(function(x,i){return S;});
    Ks = Vector.Zero(N).map(function(x,i){return minK + (maxK-minK)*(i-1)/(N-1);});
    CallPuts = Vector.Zero(N).map(function(x,i){return 1;return Ks.e(i)<S?-1:1;});
    payouts = getEuropeanPayouts(x, Ss, Ks, CallPuts);
    Cs = getExpectedPayouts(payouts, pdf);
    //plot("chart_C",Ks.elements,Cs.elements,"K","C");
    IVs = Cs.map(function(x,i){ try { return black_scholes_iv(CallPuts.e(i),S,Ks.e(i),0,T,Cs.e(i)); } catch(err) { return NaN; } });

    //plot("chart_IV",Ks.elements,IVs.elements,'BlachScholes Implied Volatility',"K","BS Implied Vol");
    data = new Array();
    data.push(['K','Fitted Implied Vol','Original Implied Vol']);
    for(i=0; i<N; i++) {
      data.push([Math.round(Ks.elements[i]*100)/100, Math.round(IVs.elements[i]*10000)/10000, null]);
    }
    for(i=0; i<Ks_.elements.length; i++) {
      data.push([Ks_.e(i+1), null, IVs_.e(i+1)]);
    }
    plotDataTableArray("chart_IV", data, 'BlachScholes Implied Volatility',"K","Implied Volatility");
  }
  
  function calibrate(data) {
    S = 100;
    T = 1;
    r = 0;
    nData = data.length;
    CallPuts = Vector.Zero(nData);
    Ks = Vector.Zero(nData);
    IVs = Vector.Zero(nData);
    Cs = Vector.Zero(nData);
    for(i=0; i<nData; i++) {
      CallPuts.elements[i] = 1;//data[i][0];
      Ks.elements[i] = data[i][0];
      IV = data[i][1];
      IVs.elements[i] = IV;
      Cs.elements[i] = black_scholes(CallPuts.elements[i],S,Ks.elements[i],r,IV,T) // option value
    }
    var N = 1000;
    var dx = 0.01;
    x = generateGrid(N, dx);
    var pdf;
    pdf = fitPdf(x, dx, S, Ks, CallPuts, Cs);
    plotResults(pdf, S, Ks, IVs, T, r);
  }
  
  function main() {
    var data = [
      [/*1,*/ 90, 0.25],
      [/*1,*/ 100, 0.24],
      [/*1,*/ 110, 0.26],
    ];
    handsontableOptions = {
      data: data,
      minSpareRows: 1,
      rowHeaders: true,
      colHeaders: true,
      contextMenu: true,
      colHeaders: [/*"CallPut",*/ "Strike", "Implied Vol"],
      columns: [
        //{data: 0, type: 'numeric', format: '0'},
        {data: 0, type: 'numeric', format: '0.00'},
        {data: 1, type: 'numeric', format: '0%'}
      ]
    };
    var checkRowError = function(data, iRow) {
      row = data[iRow];
      if(row.length!=2) return false;
      for(j=0; j<2; j++) {
        if(isNaN(parseFloat(row[j])) || !isFinite(row[j])) {
          return false;
        }
      }
      return true;
    }
    var checkRowWarning = function(data, iRow) {
      row = data[iRow];
      //if(row[0]!=1 && row[0]!=-1) return "Error: CallPut in row "+iRow+" is not equal to 1 or -1."
      for(j=0; j<2; j++) {
        if(row[j]<=0) return "Error: row "+iRow+", column "+j+" is not positive."
      }
      if(row[1] > 1 || row[1]<0.05) return "Error: Implied Volatility in row "+iRow+" is out of range [5%, 100%]."
      return 'OK';
    }
    options = {
      'handsontableOptions':handsontableOptions,
      'validationFunction':function(data){
        nCorrect = 0;
        for(i = 0; i<data.length; i++) {
          if(checkRowError(data, i)) {
            msg = checkRowWarning(data, i);
            if(msg!='OK') {
              return msg;
            }
            nCorrect++;
          }
        }
        if(nCorrect == 0) return 'Error: no options found.';
        return 'OK: '+nCorrect+' options entered.';
      },
      'onSubmit':function(data){
        var a = new Array();
        for(i = 0; i<data.length; i++) {
          if(checkRowError(data, i)) {
            a.push(data[i]);
          }
        }
        $('div#status').html("Calculating...").hide().show(0);
        $('div#chart_pdf').css({height: '500px'}).hide().show(0);
        $('div#chart_IV').css({height: '500px'}).hide().show(0);
        setTimeout(function(){
          try {
            calibrate(a);
            $('div#status').html("");
            $("html, body").animate({ scrollTop: $(document).height() }, "slow");
          } catch(e) {
            $('div#status').html(e.toString());
            $('div#chart_pdf').html("");
            $('div#chart_IV').html("");
            return;
          }
        }, 10);
      },
      'buttonLabel': 'Fit',
      'buttonCssTop': '-20px',
      'buttonCssLeft': '155px'
    };
  
    $('div#handsontable').myhandsontable(options);
  }

  $(document).ready(function(){
    main();
    //testBlackSholes();
  });
  </script>
  </html>
  -->
